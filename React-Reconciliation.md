# React-Reconciliation (协调)

## 什么是 Reconciliation

每次 react 在执行`render`函数的时候，React 都会产生一个由 React 元素组成的树，也就是所谓的虚拟 DOM，当页面有更新的时候又会产生新的一棵树，对比这两个虚拟 DOM 树不同的过程就是`Reconciliation（协调）`。

目前已有算法将一棵树转化为另一棵树的算法复杂度为`O(n^3)`，其中 n 为树中元素的个数。而这样对于页面更新来说，代价太过昂贵。因此，React 基于以下假设实现了时间复杂度为`O(n)`的算法：

1.  不同类型的两个元素将会产生不同的树
2.  开发人员可以使用一个 key prop 来指示在不同的渲染中哪些元素可以保持稳定

基于以上假设，React 官方设计了`Diffing`算法。后续通过实践证明，这些假设对几乎所有的实际情况都是有效的。

## Diffing 算法

React 将两个虚拟 DOM 树的比较分成以下几种情况：

1. **不同类型的元素**

   每当根节点具有不同类型时，React 将会拆除旧的树并从头开始构建新的树。

   当旧的树被移除时，所有旧的组件将会触发`unMount`状态，而新的组件树将会进入`Mount`阶段。

   > 不一定是组件树的根结点，可能是某个子树的根结点

2. **同一类型的 DOM 元素**

   比较同一类型的两个 React DOM 元素时，比如都是`div`，React 会查看两者的属性，保持相同的底层 DOM 节点，并只更新已更改的属性。

   ```jsx
   <div className="title" title="title" />

   <div className="header" title="title">
   ```

   通过对比以上两个 div 的属性，react 只会更新需要更新的 className，不会触发卸载事件。

3. **多个同级元素的情况**

   比如需要增加同级元素的情况，可能在 children 的第一个节点加入，也可能在最后。如果在第一个节点加入，新的组件树中的后续节点由于顺序和原来的树不一样，如果进行对比的话就需要全部更新，而这些更新是没有必要的。

   对于以上这种情况，React 的解决方式是给每一个同级节点增加唯一的 key。当使用 key 之后，React 会根据每个虚拟 DOM 上 key 进行对比，如果 key 相同，就会保持这个 DOM 不更新。因此在实际项目中可以根据项目的需要来制定 key 的规则。

## Diff 算法的思考

1. 该算法不会尝试匹配不同组件类型的子树。如果您发现自己在输出非常相似的两种组件类型之间交替，则可能需要使其类型相同。实际上，我们并没有发现这是一个问题
2. key 应该是稳定的，可预测的和独特的。不稳定的 key（如 Math.random（）生成的 key）将导致许多组件实例和 DOM 节点被不必要地重新创建，这可能会导致子组件中的性能下降和状态丢失

## Reconciliation 与渲染

DOM 只是 React 可以渲染的渲染环境之一，还可以通过 React Native 进行本地 IOS 和 Android 试图。（这就是为什么不推荐使用虚拟 DOM 来描述，这些只是 React 对象）

React 的设计就是使 Reconciliation 和渲染是分开的，reconciler 完成了计算树的哪些部分已经改变的工作；然后渲染器使用该信息实际更新呈现的应用程序。

而`Fiber`重新实现了 reconciler。
